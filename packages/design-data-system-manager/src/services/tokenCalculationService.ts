import type { Token, TokenValue } from '@token-model/data-model';
import { Algorithm, Variable, Formula } from '../types/algorithm';
import { AlgorithmExecutionService } from './algorithmExecutionService';

export interface TokenCalculationState {
  tokenId: string;
  originalValue: TokenValue;
  calculatedValue: TokenValue;
  hasChanges: boolean;
  iterationValue: number;
  error?: string;
  affectedFormulas?: string[]; // Track which formulas affect this token
}

export interface FormulaDependency {
  formulaId: string;
  formulaName: string;
  affectedTokens: string[];
  dependencies: string[]; // Variable names this formula depends on
}

export class TokenCalculationService {
  /**
   * Find all tokens generated by a specific algorithm
   */
  static findTokensByAlgorithm(algorithmId: string, tokens: Token[]): Token[] {
    return tokens.filter(token => 
      token.generatedByAlgorithm === true && 
      token.algorithmId === algorithmId
    );
  }

  /**
   * Evaluate a formula with given variables and iteration value
   */
  static evaluateFormula(
    formula: Formula,
    variables: Variable[],
    iterationValue: number,
    context: Record<string, unknown> = {}
  ): number | string | boolean {
    try {
      // Create evaluation context with variables and system variables
      const evalContext: Record<string, unknown> = {
        n: iterationValue, // System variable
        ...context,
        // Add user variables with their default values
        ...variables.reduce((acc, variable) => {
          acc[variable.name] = this.parseVariableValue(variable.defaultValue || '', variable.type);
          return acc;
        }, {} as Record<string, unknown>)
      };

      // Use the new AlgorithmExecutionService for formula evaluation
      return AlgorithmExecutionService.evaluateFormula(formula, evalContext) as number | string | boolean;
    } catch (error) {
      console.error('Formula evaluation error:', error);
      throw new Error(`Formula evaluation failed: ${error}`);
    }
  }

  /**
   * Parse variable value based on its type
   */
  private static parseVariableValue(value: string, type: Variable['type']): unknown {
    switch (type) {
      case 'number':
        return Number(value) || 0;
      case 'string':
        return String(value);
      case 'boolean':
        return value === 'true' || value === '1';
      default:
        return value;
    }
  }

  /**
   * Calculate token values based on algorithm state
   */
  static calculateTokenValues(
    algorithm: Algorithm,
    tokens: Token[]
  ): Map<string, TokenCalculationState> {
    const results = new Map<string, TokenCalculationState>();
    
    if (!algorithm.tokenGeneration?.enabled) {
      return results;
    }

    const algorithmTokens = this.findTokensByAlgorithm(algorithm.id, tokens);

    // Use the new AlgorithmExecutionService to generate expected values
    const expectedResults = AlgorithmExecutionService.generateTokensForAlgorithm(algorithm);

    // Calculate values for each token
    algorithmTokens.forEach(token => {
      try {
        // Find the expected result for this token
        const expectedResult = expectedResults.find(result => result.tokenId === token.id);
        
        if (expectedResult) {
          const originalValue = token.valuesByMode[0]?.value || { value: '' };
          const hasChanges = this.valuesAreDifferent(originalValue, expectedResult.value);

          const calculationState: TokenCalculationState = {
            tokenId: token.id,
            originalValue,
            calculatedValue: expectedResult.value,
            hasChanges,
            iterationValue: expectedResult.iterationValue,
            affectedFormulas: [expectedResult.formulaName]
          };

          results.set(token.id, calculationState);
        } else {
          // Token not found in expected results - mark as error
          results.set(token.id, {
            tokenId: token.id,
            originalValue: token.valuesByMode[0]?.value || { value: '' },
            calculatedValue: { value: '' },
            hasChanges: false,
            iterationValue: 0,
            error: 'Token not found in algorithm execution results'
          });
        }
      } catch (error) {
        console.error(`Error processing token ${token.id}:`, error);
        results.set(token.id, {
          tokenId: token.id,
          originalValue: token.valuesByMode[0]?.value || { value: '' },
          calculatedValue: { value: '' },
          hasChanges: false,
          iterationValue: 0,
          error: `Calculation failed: ${error}`
        });
      }
    });

    return results;
  }

  /**
   * Execute algorithm steps to get final value (legacy method - use AlgorithmExecutionService instead)
   */
  private static executeAlgorithmSteps(algorithm: Algorithm, iterationValue: number): unknown {
    // Use the new AlgorithmExecutionService
    const executionContext = AlgorithmExecutionService.executeAlgorithm(algorithm, iterationValue);
    return executionContext.finalResult;
  }

  /**
   * Compare two TokenValue objects to determine if they're different
   */
  private static valuesAreDifferent(value1: TokenValue, value2: TokenValue): boolean {
    if ('tokenId' in value1 && 'tokenId' in value2) {
      return value1.tokenId !== value2.tokenId;
    }
    
    if ('value' in value1 && 'value' in value2) {
      return value1.value !== value2.value;
    }
    
    return true; // Different structures
  }

  /**
   * Calculate a simple difference metric between two values
   */
  private static calculateValueDifference(value1: TokenValue, value2: TokenValue): number {
    if ('value' in value1 && 'value' in value2) {
      const v1 = Number(value1.value) || 0;
      const v2 = Number(value2.value) || 0;
      return Math.abs(v1 - v2);
    }
    return Infinity; // Can't compare
  }

  /**
   * Analyze formula dependencies to determine which tokens are affected by formula changes
   */
  static analyzeFormulaDependencies(algorithm: Algorithm, tokens: Token[]): FormulaDependency[] {
    const dependencies: FormulaDependency[] = [];
    const algorithmTokens = this.findTokensByAlgorithm(algorithm.id, tokens);

    algorithm.formulas.forEach(formula => {
      // Extract variable dependencies from formula expression
      const variableDependencies = this.extractVariableDependencies(formula.expressions.javascript.value);
      
      // Find tokens that might be affected by this formula
      // This is a simplified approach - in practice, we'd need more sophisticated analysis
      const affectedTokens = algorithmTokens.map(token => token.id);

      dependencies.push({
        formulaId: formula.id,
        formulaName: formula.name,
        affectedTokens,
        dependencies: variableDependencies
      });
    });

    return dependencies;
  }

  /**
   * Extract variable names from a JavaScript expression
   */
  private static extractVariableDependencies(expression: string): string[] {
    const dependencies: string[] = [];
    
    // Simple regex to find variable names (excluding function names and keywords)
    const variablePattern = /\b[a-zA-Z_$][a-zA-Z0-9_$]*\b/g;
    const matches = expression.match(variablePattern) || [];
    
    // Filter out common JavaScript keywords and functions
    const keywords = ['Math', 'sin', 'cos', 'tan', 'sqrt', 'pow', 'abs', 'round', 'floor', 'ceil', 'max', 'min'];
    const systemVars = ['n']; // System variables
    
    matches.forEach(match => {
      if (!keywords.includes(match) && !systemVars.includes(match)) {
        dependencies.push(match);
      }
    });

    return [...new Set(dependencies)]; // Remove duplicates
  }

  /**
   * Get tokens that need recalculation when a specific formula changes
   */
  static getTokensForFormulaRecalculation(
    changedFormulaId: string,
    algorithm: Algorithm,
    tokens: Token[]
  ): string[] {
    const dependencies = this.analyzeFormulaDependencies(algorithm, tokens);
    const formulaDependency = dependencies.find(dep => dep.formulaId === changedFormulaId);
    
    return formulaDependency?.affectedTokens || [];
  }

  /**
   * Calculate token values with selective recalculation based on formula changes
   */
  static calculateTokenValuesSelective(
    algorithm: Algorithm,
    tokens: Token[],
    changedFormulaIds?: string[]
  ): Map<string, TokenCalculationState> {
    const results = new Map<string, TokenCalculationState>();
    
    if (!algorithm.tokenGeneration?.enabled) {
      return results;
    }

    const algorithmTokens = this.findTokensByAlgorithm(algorithm.id, tokens);

    // If specific formulas changed, only recalculate affected tokens
    const tokensToCalculate = changedFormulaIds 
      ? algorithmTokens.filter(token => {
          const affectedTokens = changedFormulaIds.flatMap(formulaId => 
            this.getTokensForFormulaRecalculation(formulaId, algorithm, tokens)
          );
          return affectedTokens.includes(token.id);
        })
      : algorithmTokens;

    // Use the new AlgorithmExecutionService to generate expected values
    const expectedResults = AlgorithmExecutionService.generateTokensForAlgorithm(algorithm);

    // Calculate values for each token
    tokensToCalculate.forEach(token => {
      try {
        const expectedResult = expectedResults.find(result => result.tokenId === token.id);
        
        if (expectedResult) {
          const originalValue = token.valuesByMode[0]?.value || { value: '' };
          const hasChanges = this.valuesAreDifferent(originalValue, expectedResult.value);

          const calculationState: TokenCalculationState = {
            tokenId: token.id,
            originalValue,
            calculatedValue: expectedResult.value,
            hasChanges,
            iterationValue: expectedResult.iterationValue,
            affectedFormulas: changedFormulaIds || [expectedResult.formulaName]
          };

          results.set(token.id, calculationState);
        } else {
          results.set(token.id, {
            tokenId: token.id,
            originalValue: token.valuesByMode[0]?.value || { value: '' },
            calculatedValue: { value: '' },
            hasChanges: false,
            iterationValue: 0,
            error: 'Token not found in algorithm execution results',
            affectedFormulas: changedFormulaIds || []
          });
        }
      } catch (error) {
        console.error(`Error processing token ${token.id}:`, error);
        results.set(token.id, {
          tokenId: token.id,
          originalValue: token.valuesByMode[0]?.value || { value: '' },
          calculatedValue: { value: '' },
          hasChanges: false,
          iterationValue: 0,
          error: `Calculation failed: ${error}`,
          affectedFormulas: changedFormulaIds || []
        });
      }
    });

    return results;
  }
} 