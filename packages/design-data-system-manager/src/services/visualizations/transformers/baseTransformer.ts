/**
 * Base Data Transformer Abstract Class
 * Provides common functionality for all data transformers
 * Adheres to @project-rules.mdc and schema validation requirements
 */

import type { 
  DataTransformer, 
  TransformOptions, 
  FilterOptions, 
  VisualizationMetadata,
  VisualizationResult 
} from '../types/visualization-data';

export abstract class BaseDataTransformer<TInput, TOutput> implements DataTransformer<TInput, TOutput> {
  protected readonly transformerName: string;
  protected readonly version: string = '1.0.0';

  constructor(transformerName: string) {
    this.transformerName = transformerName;
  }

  /**
   * Abstract method that must be implemented by concrete transformers
   */
  abstract transformData(input: TInput, options?: TransformOptions): Promise<TOutput>;

  /**
   * Validate input data structure
   * Override this method for specific validation requirements
   */
  public validateInput(input: TInput): boolean {
    if (!input) {
      console.error(`[${this.transformerName}] Input is null or undefined`);
      return false;
    }
    return true;
  }

  /**
   * Apply filters to data based on filter options
   * Common filtering logic that can be reused by all transformers
   */
  protected applyFilters<T>(data: T[], filters: FilterOptions): T[] {
    if (!filters || !data) {
      return data;
    }

    let filteredData = [...data];

    // Apply token type filters if available
    if (filters.tokenTypes && filters.tokenTypes.length > 0) {
      filteredData = filteredData.filter((item: any) => {
        return filters.tokenTypes!.includes(item.resolvedValueTypeId || item.type);
      });
    }

    // Apply collection filters if available
    if (filters.collections && filters.collections.length > 0) {
      filteredData = filteredData.filter((item: any) => {
        const collectionIds = item.collectionIds || [];
        return filters.collections!.some(filterId => collectionIds.includes(filterId));
      });
    }

    // Apply platform filters if available
    if (filters.platforms && filters.platforms.length > 0) {
      filteredData = filteredData.filter((item: any) => {
        return filters.platforms!.includes(item.platformId);
      });
    }

    // Apply theme filters if available
    if (filters.themes && filters.themes.length > 0) {
      filteredData = filteredData.filter((item: any) => {
        return filters.themes!.includes(item.themeId);
      });
    }

    // Apply resolved value type filters
    if (filters.resolvedValueTypes && filters.resolvedValueTypes.length > 0) {
      filteredData = filteredData.filter((item: any) => {
        return filters.resolvedValueTypes!.includes(item.resolvedValueTypeId);
      });
    }

    // Apply dependency depth filters
    if (filters.minDependencyDepth !== undefined) {
      filteredData = filteredData.filter((item: any) => {
        const depth = item.dependencyDepth || 0;
        return depth >= filters.minDependencyDepth!;
      });
    }

    if (filters.maxDependencyDepth !== undefined) {
      filteredData = filteredData.filter((item: any) => {
        const depth = item.dependencyDepth || 0;
        return depth <= filters.maxDependencyDepth!;
      });
    }

    return filteredData;
  }

  /**
   * Enrich data with additional metadata
   * Common metadata that can be applied to all transformations
   */
  protected enrichWithMetadata<T>(data: T, inputMetadata?: Record<string, unknown>): T & { metadata?: Record<string, unknown> } {
    const enrichedData = { ...data };
    
    if (inputMetadata) {
      (enrichedData as any).metadata = {
        ...inputMetadata,
        transformedBy: this.transformerName,
        transformedAt: new Date().toISOString(),
        version: this.version
      };
    }

    return enrichedData;
  }

  /**
   * Create visualization metadata for the result
   */
  protected createVisualizationMetadata(
    dataSource: 'merged' | 'platform' | 'theme' | 'core',
    tokenCount: number,
    dependencyCount: number,
    additionalMetadata?: Record<string, unknown>
  ): VisualizationMetadata {
    return {
      title: `${this.transformerName} Visualization`,
      description: `Generated by ${this.transformerName} transformer`,
      generatedAt: new Date().toISOString(),
      dataSource,
      schemaVersion: this.version,
      tokenCount,
      dependencyCount,
      ...additionalMetadata
    };
  }

  /**
   * Create a standardized result object
   */
  protected createResult<T>(
    data: T,
    metadata: VisualizationMetadata,
    errors?: string[],
    warnings?: string[]
  ): VisualizationResult<T> {
    return {
      data,
      metadata,
      ...(errors && errors.length > 0 && { errors }),
      ...(warnings && warnings.length > 0 && { warnings })
    };
  }

  /**
   * Log transformation progress for debugging
   */
  protected logProgress(stage: string, details?: Record<string, unknown>): void {
    console.log(`[${this.transformerName}] ${stage}`, details || '');
  }

  /**
   * Handle and log errors consistently
   */
  protected handleError(error: Error, context: string): never {
    console.error(`[${this.transformerName}] Error in ${context}:`, error);
    throw new Error(`${this.transformerName} failed during ${context}: ${error.message}`);
  }
}
